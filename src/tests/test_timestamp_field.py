"""
Tests of the timestamp field.

"""

import datetime
import inspect

import django.core.exceptions
import django.core.management
import django.db
import django.test

import django_forcedfields
from . import models as test_models
from . import utils as test_utils


class TestTimestampField(django.test.TransactionTestCase):
    """
    Since Django test cases automatically apply the INSTALLED_APPS models and migrations, any syntax
    violations in the SQL generated by the models or their fields will trigger database-level errors
    before the test cases are even run. Therefore, the test cases in this class are able to verify
    correct database field data type and parameters but cannot check for valid SQL beforehand.

    This class inherits from TransactionTestCase so that I can test database-level exceptions
    without causing the "You can't execute queries until the end of the 'atomic' block." Django
    exception message. This error was still thrown even when calling self.assertRaises and wrapping
    that in its own, explicit transaction.atomic() block. One more ORM failure/complication.

    See:
        http://stackoverflow.com/a/23326971

    TODO:
        Add db_type return value checks for sqlite3.

    """

    multi_db = True

    @classmethod
    def setUpTestData(cls):
        """
        Override parent method. Single setup for data used in majority of cases.

        """
        cls._db_aliases = test_utils.get_db_aliases()

    def _test_db_type_mysql(self):
        """
        Test output of the custom field db_type method with the MySQL backend.

        Internal component of the custom field's db_type method return values.

        """
        connection = django.db.connections[test_utils.ALIAS_MYSQL]
        for config in test_utils.TS_FIELD_TEST_CONFIGS:
            current_kwargs_string = ', '.join(config.kwargs_dict.keys())
            with self.subTest(arguments=current_kwargs_string):
                test_field = django_forcedfields.TimestampField(**config.kwargs_dict)
                self.assertEqual(test_field.db_type(connection), config.db_type_mysql)

    def _test_db_type_postgresql(self):
        """
        Test output of custom field db_type method with the PostgreSQL backend.

        Internal component of the custom field's db_type method return values.

        """
        connection = django.db.connections[test_utils.ALIAS_POSTGRESQL]
        for config in test_utils.TS_FIELD_TEST_CONFIGS:
            current_kwargs_string = ', '.join(config.kwargs_dict.keys())
            with self.subTest(arguments=current_kwargs_string):
                test_field = django_forcedfields.TimestampField(**config.kwargs_dict)
                self.assertEqual(test_field.db_type(connection), config.db_type_postgresql)

    def _test_insert_values(self, test_model_class, values_dict):
        """
        Iteratively instantiate test model classes with different field values.

        This is part of a test of the INSERT operations with the timestamp field. This method is
        defined separately to break up deep nesting of blocks.

        Args:
            test_model_class (tests.models.*): The test Django model class.
            values_dict (dict): The timestamp field test config attribute containing model field
                attribute values and expected database values fetched after insert.

        """
        for key, value in values_dict.items():
            with self.subTest(attr_value=key):
                self._test_insert_all_backends(test_model_class, key, value)

    def _test_insert_all_backends(self, test_model_class, attr_value, expected_value):
        """
        INSERT and SELECT field attribute value all available DB backends.

        Inserts the test values for the given model, selects the value from the database, and
        compares the result with the expected value.

        This is part of a test of the INSERT operations with the timestamp field. This method is
        defined separately to break up deep nesting of blocks.

        Args:
            test_model_class (class): The class of the current model to use in the tests.
            attr_value: The value to save in the new model instance's attribute.
            expected_value: The value that is expected to be retrieved from the database after a
                successful save() call.

        """
        for alias in test_utils.get_db_aliases():
            if attr_value is django.db.models.NOT_PROVIDED:
                test_model = test_model_class()
            else:
                test_kwargs = {test_utils.TS_FIELD_TEST_ATTRNAME: attr_value}
                test_model = test_model_class(**test_kwargs)

            engine = django.db.connections[alias].settings_dict['ENGINE']
            with self.subTest(backend=engine):
                class_expected = inspect.isclass(expected_value)
                if class_expected and issubclass(expected_value, Exception):
                    self.assertRaises(expected_value, test_model.save, using=alias)
                else:
                    test_model.save(using=alias)
                    retrieved_record_model = test_model.__class__.objects.using(alias).get(
                        id=test_model.id
                    )
                    retrieved_value = getattr(
                        retrieved_record_model,
                        test_utils.TS_FIELD_TEST_ATTRNAME
                    )
                    if class_expected:
                        retrieved_value = retrieved_value.__class__

                    self.assertEqual(retrieved_value, expected_value)

    def _test_update_insert_only(self, alias):
        """
        Test that automatic update is NOT triggered when not enabled.

        Test that the timestamp field value is unchanged when only auto_now_add is enabled.

        Unfortunately, this test is impossible to isolate from any side effects of a broken INSERT
        operation in the timestamp field.

        This is part of a test of the UPDATE operations with the timestamp field.

        Args:
            alias (string): The DATABASES Django settings key used to specify a specific database
                backend for an operation.

        """
        # Insert a record and retrieve fresh value from database.
        add_only_model_class_name = test_utils.get_ts_model_class_name(auto_now_add=True)
        add_only_class = getattr(test_models, add_only_model_class_name)
        add_only_model = add_only_class()
        add_only_model.save(using=alias)
        retrieved_model = add_only_class.objects.using(alias).get(id=add_only_model.id)
        inserted_value = getattr(retrieved_model, test_utils.TS_FIELD_TEST_ATTRNAME)

        # Update the same record and retrieve fresh value from database.
        setattr(add_only_model, test_utils.UPDATE_FIELD_TEST_ATTRNAME, 1)
        add_only_model.save()
        retrieved_model = add_only_class.objects.using(alias).get(id=add_only_model.id)
        updated_value = getattr(retrieved_model, test_utils.TS_FIELD_TEST_ATTRNAME)

        self.assertEqual(inserted_value, updated_value)

    def _test_update_update_only(self, alias):
        """
        Test that automatic update IS triggered when exclusively enabled.

        Test that the timestamp field is automatically updated when only auto_now_update is enabled.

        Unfortunately, this test is impossible to isolate from any side effects of a broken INSERT
        operation in the timestamp field.

        This is part of a test of the UPDATE operations with the timestamp field.

        Args:
            alias (string): The DATABASES Django settings key used to specify a specific database
                backend for an operation.

        """
        # Insert a record and retrieve fresh value from database.
        update_only_model_class_name = test_utils.get_ts_model_class_name(
            auto_now_update=True,
            null=True
        )
        update_only_class = getattr(test_models, update_only_model_class_name)
        update_only_model = update_only_class()
        update_only_model.save(using=alias)
        retrieved_model = update_only_class.objects.using(alias).get(id=update_only_model.id)
        inserted_value = getattr(retrieved_model, test_utils.TS_FIELD_TEST_ATTRNAME)

        # Update the same record and retrieve fresh value from database.
        setattr(update_only_model, test_utils.UPDATE_FIELD_TEST_ATTRNAME, 1)
        update_only_model.save()
        retrieved_model = update_only_class.objects.using(alias).get(id=update_only_model.id)
        updated_value = getattr(retrieved_model, test_utils.TS_FIELD_TEST_ATTRNAME)

        self.assertNotEqual(inserted_value, updated_value)

    def test_db_type(self):
        """
        Test simple output of the field's overridden "db_type" method.

        Only test thoroughly the overridden field behavior. Cursory checks will be performed to
        ensure fallback to Django default if necessary but those values will not be extensively
        checked.

        """
        backend_subtests = {
            test_utils.ALIAS_MYSQL: self._test_db_type_mysql,
            test_utils.ALIAS_POSTGRESQL: self._test_db_type_postgresql
        }

        for alias, subtest_callable in backend_subtests.items():
            db_backend = django.db.connections[alias].settings_dict['ENGINE']
            with self.subTest(backend=db_backend):
                subtest_callable()

    def test_field_argument_check(self):
        """
        Ensure keyword argument rules are enforced.

        For example, check that mutual exclusivity constraints between auto_now and auto_now_update
        are enforced. New field classes are defined here since the test models defined in
        tests.utils include only valid field argument permutations.

        For some reason, model and field check() methods are not called during test database setup
        or when dynamically creating and migrating model classes. I don't currently know where and
        when the checks are run or when the checks framework raises the returned errors. I'm just
        going to manually call the check() method here.

        I concatenate a test iteration count to the dynamic class name to prevent Django from
        issuing a warning "RuntimeWarning: Model 'tests.testmodel' was already registered." This
        error is caused by attempting to re-register a symbol in the current namespace so I ensure
        that each new invalid field class defined has a unique name.

        Note:
            "Validation" covers actual model attribute values, not the field class instance
            arguments. "Checks" cover the field class arguments and field class state.

        See:
            https://docs.djangoproject.com/en/dev/howto/custom-model-fields/#what-does-a-field-class-do
            https://docs.djangoproject.com/en/dev/topics/checks/

        """
        check_tests = {
            'fields.E160' : {
                'auto_now': True,
                'auto_now_add': True
            },
            'django_forcedfields.E160' : {
                'auto_now': True,
                'auto_now_update': True
            }
        }

        check_test_count = 0
        for check_error_id, kwargs in check_tests.items():
            test_model_members = {
                'ts_field_1': django_forcedfields.TimestampField(**kwargs),
                '__module__':  __name__
            }
            test_model_class = type(
                'TestModel' + str(check_test_count),
                (django.db.models.Model,),
                test_model_members
            )
            model_instance = test_model_class(ts_field_1='2000-01-01 00:00:01')
            check_results = model_instance.check()

            with self.subTest(field_args=', '.join(kwargs.keys())):
                self.assertEqual(len(check_results), 1)
                self.assertEqual(check_results[0].id, check_error_id)

            check_test_count = check_test_count + 1

    def test_field_deconstruction(self):
        """
        Test the custom field's deconstruct() method.

        See:
            https://docs.djangoproject.com/en/dev/howto/custom-model-fields/#field-deconstruction

        """
        test_field = django_forcedfields.TimestampField(
            auto_now_add=True,
            auto_now_update=True,
            null=True
        )
        name, path, args, kwargs = test_field.deconstruct()
        reconstructed_test_field = django_forcedfields.TimestampField(*args, **kwargs)

        self.assertEqual(test_field.auto_now, reconstructed_test_field.auto_now)
        self.assertEqual(test_field.auto_now_update, reconstructed_test_field.auto_now_update)
        self.assertEqual(test_field.null, reconstructed_test_field.null)

    def test_insert(self):
        """
        Test that the values saved during INSERT operations are correct.

        """
        for config in test_utils.TS_FIELD_TEST_CONFIGS:
            test_model_class_name = test_utils.get_ts_model_class_name(**config.kwargs_dict)
            test_model_class = getattr(test_models, test_model_class_name)
            with self.subTest(test_model=test_model_class_name):
                self._test_insert_values(test_model_class, config.insert_values_dict)

    def test_invalid_attribute_value(self):
        """
        Test that model attribute value is still validated.

        Backend doesn't matter since validation is not backend-dependent. Using MySQL here.

        Just testing to make sure that any custom field modifications haven't disrupted the parent
        DateTimeField's functionality. DateTimeField raises a ValidationError if datetime value
        cannot be parsed. The DateTimeField attempts to parse date and time from string in its
        to_python() method, raising ValidationError on failure.

        Note:
            "Validation" covers actual model attribute values, not the field class instance
            arguments. "Checks" cover the field class arguments and field class state.

        See:
            https://docs.djangoproject.com/en/dev/howto/custom-model-fields/#what-does-a-field-class-do
            https://github.com/django/django/blob/master/django/db/models/fields/__init__.py
                django.db.models.fields.DateTimeField.to_python
            https://docs.djangoproject.com/en/dev/howto/custom-model-fields/#converting-values-to-python-objects
            https://docs.djangoproject.com/en/dev/ref/models/fields/#django.db.models.Field.to_python

        """
        test_model_class_name = test_utils.get_ts_model_class_name(
            **test_utils.TS_FIELD_TEST_CONFIGS[0].kwargs_dict
        )
        test_model_class = getattr(test_models, test_model_class_name)

        test_model_kwargs = {test_utils.TS_FIELD_TEST_ATTRNAME: 'invalid'}
        test_model = test_model_class(**test_model_kwargs)

        self.assertRaises(
            django.core.exceptions.ValidationError,
            test_model.save,
            using=test_utils.ALIAS_MYSQL
        )

    def test_mysql_table_structure(self):
        """
        Test correct DB table structures with MySQL backend.

        Because all db_type method return values were tested in another test case, this method will
        only run a cursory set of checks on the actual database table structure. This module is
        supposed to test the custom field, not the underlying database.

        Note:
            information_schema.COLUMNS.COLUMN_DEFAULT is a longtext field.

        See:
            https://mariadb.com/kb/en/mariadb/create-table/
            https://mariadb.com/kb/en/mariadb/sql-statements-that-cause-an-implicit-commit/

        """
        test_model_class_name = test_utils.get_ts_model_class_name(
            **test_utils.TS_FIELD_TEST_CONFIGS[2].kwargs_dict
        )
        test_model_class = getattr(test_models, test_model_class_name)
        connection = django.db.connections[test_utils.ALIAS_MYSQL]

        sql_string = """
            SELECT
                LOWER(`DATA_TYPE`) AS `DATA_TYPE`,
                LOWER(`IS_NULLABLE`) AS `IS_NULLABLE`,
                LOWER(CAST(`COLUMN_DEFAULT` AS CHAR(32))) AS `COLUMN_DEFAULT`,
                LOWER(`EXTRA`) AS `EXTRA`
            FROM
                `information_schema`.`COLUMNS`
            WHERE
                `TABLE_SCHEMA` = %s
                AND `TABLE_NAME` = %s
                AND `COLUMN_NAME` = %s
        """
        sql_params = [
            connection.settings_dict['NAME'],
            test_model_class._meta.db_table,
            test_model_class._meta.fields[1].get_attname_column()[1]
        ]

        with connection.cursor() as cursor:
            cursor.execute(sql_string, sql_params)
            record = cursor.fetchone()

        self.assertEqual(record[0], 'timestamp')
        self.assertEqual(record[1], 'no')
        self.assertTrue(record[2].startswith('current_timestamp'))
        self.assertTrue(record[3].startswith('on update current_timestamp'))

    def test_postgresql_table_structure(self):
        """
        Test correct DB table structures with PostgreSQL backend.

        Because all db_type method return values were tested in another test case, this method will
        only run a cursory set of checks on the actual database table structure. This module is
        supposed to test the custom field, not the underlying database.

        See:
            https://www.postgresql.org/docs/current/static/infoschema-columns.html

        """
        test_model_class_name = test_utils.get_ts_model_class_name(
            **test_utils.TS_FIELD_TEST_CONFIGS[2].kwargs_dict
        )
        test_model_class = getattr(test_models, test_model_class_name)
        connection = django.db.connections[test_utils.ALIAS_POSTGRESQL]

        sql_string = """
            SELECT
                LOWER(data_type) AS data_type,
                LOWER(is_nullable) AS is_nullable,
                LOWER(column_default) AS column_default
            FROM
                information_schema.columns
            WHERE
                table_catalog = %s
                AND table_name = %s
                AND column_name = %s
        """
        sql_params = [
            connection.settings_dict['NAME'],
            test_model_class._meta.db_table,
            test_model_class._meta.fields[1].get_attname_column()[1]
        ]

        with connection.cursor() as cursor:
            cursor.execute(sql_string, sql_params)
            record = cursor.fetchone()

        self.assertEqual(record[0], 'timestamp without time zone')
        self.assertEqual(record[1], 'no')
        self.assertEqual(record[2], 'now()')

    def test_saved_value_datetime(self):
        """
        Test that the automatic timestamp value is the current datetime.

        Due to latency in operations, high precision cannot be used when comparing inserted and
        retrieved datetime values. Therefore, seconds and milliseconds are ignored and this test
        only comapres dates, hours, and minutes.

        """
        for alias in test_utils.get_db_aliases():
            engine = django.db.connections[alias].settings_dict['ENGINE']
            with self.subTest(backend=engine):
                test_model_class_name = test_utils.get_ts_model_class_name(auto_now_add=True)
                test_model_class = getattr(test_models, test_model_class_name)
                test_model = test_model_class()
                test_model.save(using=alias)
                retrieved_model = test_model_class.objects.using(alias).get(
                    id=test_model.id
                )
                retrieved_value = getattr(
                    retrieved_model,
                    test_utils.TS_FIELD_TEST_ATTRNAME
                )
                expected_value = datetime.datetime.now()

                self.assertEqual(retrieved_value.date(), expected_value.date())
                self.assertEqual(retrieved_value.hour, expected_value.hour)
                self.assertEqual(retrieved_value.minute, expected_value.minute)

    def test_sqlite3_table_structure(self):
        """
        Test correct DB table structures with sqlite3 backend.

        Because all db_type method return values were tested in another test case, this method will
        only run a cursory set of checks on the actual database table structure. This module is
        supposed to test the custom field, not the underlying database.

        Apparently PRAGMA statements cannot be prepared and/or parameterized. A sqlite syntax
        exception is raised if one attempts to pass parameters to cursor.execute().

        The PRAGMA table_info() return columns:
        >>> [desc[0] for desc in cursor.description]
        >>> ['cid', 'name', 'type', 'notnull', 'dflt_value', 'pk']

        See:
            https://www.sqlite.org/pragma.html#pragma_table_info

        """
        test_model_class_name = test_utils.get_ts_model_class_name(
            **test_utils.TS_FIELD_TEST_CONFIGS[2].kwargs_dict
        )
        test_model_class = getattr(test_models, test_model_class_name)
        connection = django.db.connections[test_utils.ALIAS_SQLITE]

        sql_string = 'PRAGMA table_info({!s})'.format(test_model_class._meta.db_table)

        with connection.cursor() as cursor:
            cursor.execute(sql_string)
            records = cursor.fetchall()
        ts_record = records[1]

        self.assertEqual(ts_record[2], 'DATETIME') # type
        self.assertEqual(ts_record[3], 1) # notnull
        self.assertEqual(ts_record[4], 'CURRENT_TIMESTAMP') # dflt_value

    def test_update(self):
        """
        Test that an UPDATE statement works correctly in specific cases.

        Test that the timestamp field value is unchanged when only auto_now_add is enabled and test
        that the timestamp field is automatically updated when only auto_now_update is enabled.

        Unfortunately, this test is impossible to isolate from any side effects of a broken INSERT
        operation in the timestamp field.

        """
        for alias in test_utils.get_db_aliases():
            engine = django.db.connections[alias].settings_dict['ENGINE']
            with self.subTest(backend=engine):
                self._test_update_insert_only(alias)
                self._test_update_update_only(alias)
