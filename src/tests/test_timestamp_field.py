"""
Tests of the timestamp field.

"""

import unittest.mock as mock

import django.core.exceptions
import django.core.management
import django.db
import django.test

from . import models as test_models
from . import utils as test_utils
import django_forcedfields


class TestTimestampField(django.test.TestCase):
    """
    Since django.test.TestCase automatically applies the INSTALLED_APPS models
    and migrations, any syntax violations in the SQL generated by the models or
    their fields will trigger database-level errors before the test suites are
    even run. Therefore, the test cases in this class are able to verify correct
    database field data type and parameters but cannot check for valid SQL
    beforehand.

    """

    multi_db = True

    @classmethod
    def setUpTestData(cls):
        """
        TODO: Get test DB entity names from Django's TestCase class directly?

        """
        cls._db_aliases = test_utils.get_db_aliases()

    def _test_db_type_mysql(self):
        """
        Test output of the custom field db_type method with the MySQL backend.

        """
        connection = django.db.connections[test_utils.ALIAS_MYSQL]
        for config in test_utils.TS_FIELD_TEST_CONFIGS:
            current_kwargs_string = ', '.join(config.kwargs_dict.keys())

            with self.subTest(arguments=current_kwargs_string):
                test_field = django_forcedfields.TimestampField(
                    **config.kwargs_dict)
                self.assertEqual(
                    test_field.db_type(connection),
                    config.db_type_mysql)

    def _test_db_type_postgresql(self):
        """
        Test output of custom field db_type method with the PostgreSQL backend.

        """
        connection = django.db.connections[test_utils.ALIAS_POSTGRESQL]
        for config in test_utils.TS_FIELD_TEST_CONFIGS:
            current_kwargs_string = ', '.join(config.kwargs_dict.keys())

            with self.subTest(arguments=current_kwargs_string):
                test_field = django_forcedfields.TimestampField(
                    **config.kwargs_dict)
                self.assertEqual(
                    test_field.db_type(connection),
                    config.db_type_postgresql)

    def test_db_type(self):
        """
        Test simple output of the field's overridden "db_type" method.

        Only test thoroughly the overridden field behavior. Cursory checks will
        be performed to ensure fallback to Django default if necessary but
        those values will not be extensively checked.

        """
        backend_subtests = {
            test_utils.ALIAS_MYSQL: self._test_db_type_mysql,
            test_utils.ALIAS_POSTGRESQL: self._test_db_type_postgresql}

        for alias, subtest_callable in backend_subtests.items():
            db_backend = django.db.connections[alias].settings_dict['ENGINE']
            with self.subTest(backend=db_backend):
                subtest_callable()

    def test_field_argument_check(self):
        """
        Ensure keyword argument rules are enforced.

        For some reason, model and field check() methods are not called during
        test database setup or when dynamically creating and migrating model
        classes. I don't know where and when the checks are run or when the
        checks framework raises the returned errors.

        I'm just going to manually call the check() method here.

        Note:
            Validation covers actual model attribute values, not the field class
            instance arguments. Checks cover the field class arguments and
            field class state.

        See:
            https://docs.djangoproject.com/en/dev/topics/checks/

        """
        check_tests = {
            'fields.E160' : {
                'auto_now': True,
                'auto_now_add': True},
            'django_forcedfields.E160' : {
                'auto_now': True,
                'auto_now_update': True}}

        for check_error_id, kwargs in check_tests.items():
            test_model_members = {
                'ts_field_1': django_forcedfields.TimestampField(**kwargs),
                '__module__':  __name__}
            TestModel = type(
                'TestModel',
                (django.db.models.Model,),
                test_model_members)
            model_instance = TestModel(ts_field_1='2000-01-01 00:00:01')
            check_results = model_instance.check()

            with self.subTest(field_args=', '.join(kwargs.keys())):
                self.assertEqual(len(check_results), 1)
                self.assertEqual(check_results[0].id, check_error_id)

    def test_field_deconstruction(self):
        """
        Test the custom field's deconstruct() method.

        See:
            https://docs.djangoproject.com/en/dev/howto/custom-model-fields/#field-deconstruction

        """
        test_field = django_forcedfields.TimestampField(
            auto_now_add=True,
            auto_now_update=True,
            null=True)
        name, path, args, kwargs = test_field.deconstruct()
        reconstructed_test_field = django_forcedfields.TimestampField(
            *args,
            **kwargs)

        self.assertEqual(test_field.auto_now, reconstructed_test_field.auto_now)
        self.assertEqual(
            test_field.auto_now_update,
            reconstructed_test_field.auto_now_update)
        self.assertEqual(test_field.null, reconstructed_test_field.null)

    def test_mysql_table_structure(self):
        """
        Test correct DB table structures with MySQL backend.

        Because all db_type method return values were tested in another test
        case, this method will only run a cursory set of checks on the actual
        database table structure. This module is supposed to test the custom
        field, not the underlying database.

        information_schema.COLUMNS.COLUMN_DEFAULT is a longtext field.

        See:
            https://mariadb.com/kb/en/mariadb/create-table/
            https://mariadb.com/kb/en/mariadb/sql-statements-that-cause-an-implicit-commit/

        """
        test_model_class_name = test_utils.get_ts_field_test_model_class_name(
            **test_utils.TS_FIELD_TEST_CONFIGS[0].kwargs_dict)
        test_model = getattr(test_models, test_model_class_name)
        connection = django.db.connections[test_utils.ALIAS_MYSQL]

        sql_string = """
            SELECT
                LOWER(`DATA_TYPE`) AS `DATA_TYPE`,
                LOWER(`IS_NULLABLE`) AS `IS_NULLABLE`,
                LOWER(CAST(`COLUMN_DEFAULT` AS CHAR(32))) AS `COLUMN_DEFAULT`,
                LOWER(`EXTRA`) AS `EXTRA`
            FROM
                `information_schema`.`COLUMNS`
            WHERE
                `TABLE_SCHEMA` = %s
                AND `TABLE_NAME` = %s
                AND `COLUMN_NAME` = %s
        """
        sql_params = [
            connection.settings_dict['NAME'],
            test_model._meta.db_table,
            test_model._meta.fields[1].get_attname_column()[1]]

        with connection.cursor() as cursor:
            cursor.execute(sql_string, sql_params)
            record = cursor.fetchone()

        self.assertEqual(record[0], 'timestamp')
        self.assertEqual(record[1], 'no')
        self.assertEqual(record[2], 'current_timestamp')
        self.assertEqual(record[3], 'on update current_timestamp')

    def test_postgresql_table_structure(self):
        """
        Test correct DB table structures with PostgreSQL backend.

        Because all db_type method return values were tested in another test
        case, this method will only run a cursory set of checks on the actual
        database table structure. This module is supposed to test the custom
        field, not the underlying database.

        information_schema.COLUMNS.COLUMN_DEFAULT is a longtext field.

        See:
            https://mariadb.com/kb/en/mariadb/create-table/
            https://mariadb.com/kb/en/mariadb/sql-statements-that-cause-an-implicit-commit/

        """
        test_model_class_name = test_utils.get_ts_field_test_model_class_name(
            **test_utils.TS_FIELD_TEST_CONFIGS[0].kwargs_dict)
        test_model = getattr(test_models, test_model_class_name)
        connection = django.db.connections[test_utils.ALIAS_POSTGRESQL]

        sql_string = """
            SELECT
                LOWER(data_type) AS data_type,
                LOWER(is_nullable) AS is_nullable,
                LOWER(column_default) AS column_default
            FROM
                information_schema.columns
            WHERE
                table_catalog = %s
                AND table_name = %s
                AND column_name = %s
        """
        sql_params = [
            connection.settings_dict['NAME'],
            test_model._meta.db_table,
            test_model._meta.fields[1].get_attname_column()[1]]

        with connection.cursor() as cursor:
            cursor.execute(sql_string, sql_params)
            record = cursor.fetchone()

        self.assertEqual(record[0], 'timestamp without time zone')
        self.assertEqual(record[1], 'no')
        self.assertEqual(record[2], 'now()')

    def test_field_values(self):
        """
        Test that the output values are correct in final SQL statements.

        For MySQL, this should bypass most of the django.db.DateTimeField value
        overrides.

        """
        raise NotImplementedError('Complete this test you lazy bastard.')
