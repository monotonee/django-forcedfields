"""
Tests for TimestampField.

"""

# Accessing models' _meta attribute violates pylint rule.
# pylint: disable=protected-access


import datetime

import django.core.exceptions
import django.core.management
import django.db
import django.test

import django_forcedfields
from . import models as test_models
from . import utils as test_utils


class TestTimestampField(django.test.TransactionTestCase, test_utils.FieldTestConfigUtilityMixin):
    """
    Since Django test cases automatically apply the INSTALLED_APPS models and migrations, any syntax
    violations in the SQL generated by the models or their fields will trigger database-level errors
    before the test cases are even run. Therefore, the test cases in this class are able to verify
    correct database field data type and parameters but cannot check for valid SQL beforehand.

    This class inherits from TransactionTestCase so that I can test database-level exceptions
    without causing the "You can't execute queries until the end of the 'atomic' block." Django
    exception message. This error was still thrown even when calling self.assertRaises and wrapping
    that in its own, explicit transaction.atomic() block. One more ORM failure/complication.

    See:
        http://stackoverflow.com/a/23326971
        https://docs.djangoproject.com/en/dev/topics/testing/tools/#transactiontestcase

    """

    multi_db = True

    def _assert_datetime_equal(self, datetime_1, datetime_2):
        """
        Assert two datetime.datetime values are equal.

        This method does NOT compare any division of time smaller than a minute, i.e. seconds and
        milliseconds, if present, are not considered in equality.

        Args:
            datetime_1 (datetime.datetime): The first (left) value to compare.
            datetime_2 (datetime.datetime): The second (right) value to compare.

        """
        self.assertEqual(datetime_1.date(), datetime_2.date())
        self.assertEqual(datetime_1.hour, datetime_2.hour)
        self.assertEqual(datetime_1.minute, datetime_2.minute)

    def _assert_datetime_not_equal(self, datetime_1, datetime_2):
        """
        Assert two datetime.datetime values are NOT equal.

        This method does NOT compare any division of time smaller than a minute, i.e. seconds and
        milliseconds, if present, are not considered in the equality test.

        This could also be implemented with datetime.replace() to zero out seconds and microseconds.

        Args:
            datetime_1 (datetime.datetime): The first (left) value to compare.
            datetime_2 (datetime.datetime): The second (right) value to compare.

        """
        required_datetime_attributes = ['date', 'hour', 'minute']
        datetime_1_has_interface = set(dir(datetime_1)).issuperset(required_datetime_attributes)
        datetime_2_has_interface = set(dir(datetime_2)).issuperset(required_datetime_attributes)

        if datetime_1_has_interface and datetime_2_has_interface:
            self.assertNotEqual(datetime_1.date(), datetime_2.date())
            self.assertNotEqual(datetime_1.hour, datetime_2.hour)
            self.assertNotEqual(datetime_1.minute, datetime_2.minute)
        else:
            self.assertNotEqual(datetime_1, datetime_2)

    def _test_update_no_auto(self, alias):
        """
        Test that automatic update is NOT triggered when not enabled.

        Test that the timestamp field value is unchanged when only auto_now_add is enabled.

        Unfortunately, this test is impossible to isolate from any side effects of a broken INSERT
        operation in the timestamp field.

        This is part of a test of the UPDATE operations with the timestamp field.

        Args:
            alias (string): The DATABASES Django settings key used to specify a specific database
                backend for an operation.

        """
        # Insert a record and retrieve inserted value from database.
        add_only_model_class_name = test_utils.get_ts_model_class_name(auto_now_add=True)
        add_only_class = getattr(test_models, add_only_model_class_name)
        add_only_model = add_only_class()
        add_only_model.save(using=alias)
        retrieved_model = add_only_class.objects.using(alias).get(id=add_only_model.id)
        inserted_value = getattr(retrieved_model, test_utils.TS_FIELD_ATTRNAME)

        # Update the same record and retrieve value of timestamp field from database.
        setattr(add_only_model, test_utils.TS_UPDATE_FIELD_ATTRNAME, 1)
        add_only_model.save(using=alias)
        retrieved_model = add_only_class.objects.using(alias).get(id=add_only_model.id)
        updated_value = getattr(retrieved_model, test_utils.TS_FIELD_ATTRNAME)

        self._assert_datetime_equal(inserted_value, updated_value)

    def _test_update_auto(self, alias):
        """
        Test that automatic update IS triggered when exclusively enabled.

        Test that the timestamp field is automatically updated when only auto_now_update is enabled.

        Unfortunately, this test is impossible to isolate from any side effects of a broken INSERT
        operation in the timestamp field.

        This is part of a test of the UPDATE operations with the timestamp field.

        Args:
            alias (string): The DATABASES Django settings key used to specify a specific database
                backend for an operation.

        """
        # Insert a record and retrieve inserted value from database.
        update_only_model_class_name = test_utils.get_ts_model_class_name(
            auto_now_update=True,
            null=True
        )
        update_only_class = getattr(test_models, update_only_model_class_name)
        update_only_model = update_only_class()
        update_only_model.save(using=alias)
        retrieved_model = update_only_class.objects.using(alias).get(id=update_only_model.id)
        inserted_value = getattr(retrieved_model, test_utils.TS_FIELD_ATTRNAME)

        # Update the same record and retrieve new auto current timestamp value from database.
        setattr(update_only_model, test_utils.TS_UPDATE_FIELD_ATTRNAME, 1)
        update_only_model.save(using=alias)
        retrieved_model = update_only_class.objects.using(alias).get(id=update_only_model.id)
        updated_value = getattr(retrieved_model, test_utils.TS_FIELD_ATTRNAME)

        self._assert_datetime_not_equal(inserted_value, updated_value)

    def test_automatic_datetime(self):
        """
        Test that the automatic timestamp value is the current datetime.

        Due to latency in operations, high precision cannot be used when comparing inserted and
        retrieved datetime values. Therefore, seconds and milliseconds are ignored and this test
        only comapres dates, hours, and minutes.

        """
        for alias in test_utils.get_db_aliases():
            engine = django.db.connections[alias].settings_dict['ENGINE']
            with self.subTest(backend=engine):
                test_model_class_name = test_utils.get_ts_model_class_name(auto_now_add=True)
                test_model_class = getattr(test_models, test_model_class_name)
                test_model = test_model_class()
                test_model.save(using=alias)
                retrieved_model = test_model_class.objects.using(alias).get(
                    id=test_model.id
                )
                retrieved_value = getattr(
                    retrieved_model,
                    test_utils.TS_FIELD_ATTRNAME
                )
                expected_value = datetime.datetime.now()

                self._assert_datetime_equal(retrieved_value, expected_value)

    def test_db_type(self):
        """
        Test output of the field's overridden "db_type" method.

        The Field.db_type() method is responsible for generating most of the SQL field's DDL such
        as field data type, defaults, ON UPDATE clauses, etc. Ensure that db_type is generating
        accurate DDL for the given field kwarg combination.

        """
        for test_config in test_utils.TS_TEST_CONFIGS:
            test_field = django_forcedfields.TimestampField(**test_config.kwargs_dict)
            test_kwargs_string = ', '.join(test_config.kwargs_dict.keys())
            for alias, expected_output in test_config.db_type_dict.items():
                connection = django.db.connections[alias]
                connection_engine = connection.settings_dict['ENGINE']
                with self.subTest(backend=connection_engine, kwargs=test_kwargs_string):
                    self.assertEqual(test_field.db_type(connection), expected_output)

    def test_field_argument_check(self):
        """
        Ensure keyword argument rules are enforced.

        For example, check that mutual exclusivity constraints between auto_now and auto_now_update
        are enforced. New field classes are defined here since the test models defined in
        tests.utils include only valid field argument permutations.

        For some reason, model and field check() methods are not called during test database setup
        or when dynamically creating and migrating model classes. I don't currently know where and
        when the checks are run or when the checks framework raises the returned errors. I'm just
        going to manually call the check() method here.

        I concatenate a test iteration count to the dynamic class name to prevent Django from
        issuing a warning "RuntimeWarning: Model 'tests.testmodel' was already registered." This
        error is caused by attempting to re-register a symbol in the current namespace so I ensure
        that each new invalid field class defined has a unique name.

        Note:
            "Validation" covers actual model attribute values, not the field class instance
            arguments. "Checks" cover the field class arguments and field class state.

        See:
            https://docs.djangoproject.com/en/dev/howto/custom-model-fields/#what-does-a-field-class-do
            https://docs.djangoproject.com/en/dev/topics/checks/

        """
        check_tests = {
            'fields.E160' : {
                'auto_now': True,
                'auto_now_add': True
            },
            'django_forcedfields.E160' : {
                'auto_now': True,
                'auto_now_update': True
            }
        }

        check_test_count = 0
        for check_error_id, kwargs in check_tests.items():
            test_model_members = {
                'ts_field_1': django_forcedfields.TimestampField(**kwargs),
                '__module__':  __name__
            }
            test_model_class = type(
                'TestModel' + str(check_test_count),
                (django.db.models.Model,),
                test_model_members
            )
            model_instance = test_model_class(ts_field_1='2000-01-01 00:00:01')
            check_results = model_instance.check()

            with self.subTest(field_args=', '.join(kwargs.keys())):
                self.assertEqual(len(check_results), 1)
                self.assertEqual(check_results[0].id, check_error_id)

            check_test_count = check_test_count + 1

    def test_field_deconstruction(self):
        """
        Test the custom field's deconstruct() method.

        See:
            https://docs.djangoproject.com/en/dev/howto/custom-model-fields/#field-deconstruction

        """
        test_field = django_forcedfields.TimestampField(
            auto_now_add=True,
            auto_now_update=True,
            null=True
        )
        name, path, args, kwargs = test_field.deconstruct() # pylint: disable=unused-variable
        reconstructed_test_field = django_forcedfields.TimestampField(*args, **kwargs)

        self.assertEqual(test_field.auto_now, reconstructed_test_field.auto_now)
        self.assertEqual(test_field.auto_now_update, reconstructed_test_field.auto_now_update)
        self.assertEqual(test_field.null, reconstructed_test_field.null)

    def test_insert(self):
        """
        Test that the values saved during INSERT operations are correct.

        """
        for test_config in test_utils.TS_TEST_CONFIGS:
            kwargs_string = test_utils.create_dict_string(test_config.kwargs_dict)
            model_class_name = test_utils.get_ts_model_class_name(**test_config.kwargs_dict)
            model_class = getattr(test_models, model_class_name)
            for insert_value, expected_value in test_config.insert_values_dict.items():
                for db_alias in test_utils.get_db_aliases():
                    with self.subTest(
                        backend=db_alias,
                        kwargs=kwargs_string,
                        insert_value=insert_value
                    ):
                        self._test_insert_dict(
                            db_alias,
                            model_class,
                            test_utils.TS_FIELD_ATTRNAME,
                            insert_value,
                            expected_value
                        )

    def test_invalid_attribute_value(self):
        """
        Test that model attribute value is still validated.

        Backend doesn't matter since validation is not backend-dependent. Using MySQL here.

        Just testing to make sure that any custom field modifications haven't disrupted the parent
        DateTimeField's functionality. DateTimeField raises a ValidationError if datetime value
        cannot be parsed. The DateTimeField attempts to parse date and time from string in its
        to_python() method, raising ValidationError on failure.

        Note:
            "Validation" covers actual model attribute values, not the field class instance
            arguments. "Checks" cover the field class arguments and field class state.

        See:
            https://docs.djangoproject.com/en/dev/howto/custom-model-fields/#what-does-a-field-class-do
            https://github.com/django/django/blob/master/django/db/models/fields/__init__.py
                django.db.models.fields.DateTimeField.to_python
            https://docs.djangoproject.com/en/dev/howto/custom-model-fields/#converting-values-to-python-objects
            https://docs.djangoproject.com/en/dev/ref/models/fields/#django.db.models.Field.to_python

        """
        test_model_class_name = test_utils.get_ts_model_class_name(
            **test_utils.TS_TEST_CONFIGS[0].kwargs_dict
        )
        test_model_class = getattr(test_models, test_model_class_name)

        test_model_kwargs = {test_utils.TS_FIELD_ATTRNAME: 'invalid'}
        test_model = test_model_class(**test_model_kwargs)

        self.assertRaises(
            django.core.exceptions.ValidationError,
            test_model.save,
            using=test_utils.ALIAS_MYSQL
        )

    def test_table_structure_mysql(self):
        """
        Test correct DB table structures with MySQL backend.

        Because all db_type method return values were tested in another test case, this method will
        only run a cursory set of checks on the actual database table structure. This module is
        supposed to test the custom field, not the underlying database.

        Note:
            information_schema.COLUMNS.COLUMN_DEFAULT is a longtext field.

        See:
            https://mariadb.com/kb/en/mariadb/create-table/
            https://mariadb.com/kb/en/mariadb/sql-statements-that-cause-an-implicit-commit/

        """
        test_model_class_name = test_utils.get_ts_model_class_name(
            **test_utils.TS_TEST_CONFIGS[2].kwargs_dict
        )
        test_model_class = getattr(test_models, test_model_class_name)
        connection = django.db.connections[test_utils.ALIAS_MYSQL]

        sql_string = """
            SELECT
                LOWER(`DATA_TYPE`) AS `DATA_TYPE`,
                LOWER(`IS_NULLABLE`) AS `IS_NULLABLE`,
                LOWER(CAST(`COLUMN_DEFAULT` AS CHAR(32))) AS `COLUMN_DEFAULT`,
                LOWER(`EXTRA`) AS `EXTRA`
            FROM
                `information_schema`.`COLUMNS`
            WHERE
                `TABLE_SCHEMA` = %s
                AND `TABLE_NAME` = %s
                AND `COLUMN_NAME` = %s
        """
        sql_params = [
            connection.settings_dict['NAME'],
            test_model_class._meta.db_table,
            test_model_class._meta.fields[1].get_attname_column()[1]
        ]

        with connection.cursor() as cursor:
            cursor.execute(sql_string, sql_params)
            record = cursor.fetchone()

        self.assertEqual(record[0], 'timestamp')
        self.assertEqual(record[1], 'no')
        self.assertTrue(record[2].startswith('current_timestamp'))
        self.assertTrue(record[3].startswith('on update current_timestamp'))

    def test_table_structure_postgresql(self):
        """
        Test correct DB table structures with PostgreSQL backend.

        Because all db_type method return values were tested in another test case, this method will
        only run a cursory set of checks on the actual database table structure. This module is
        supposed to test the custom field, not the underlying database.

        See:
            https://www.postgresql.org/docs/current/static/infoschema-columns.html

        """
        test_model_class_name = test_utils.get_ts_model_class_name(
            **test_utils.TS_TEST_CONFIGS[2].kwargs_dict
        )
        test_model_class = getattr(test_models, test_model_class_name)
        connection = django.db.connections[test_utils.ALIAS_POSTGRESQL]

        sql_string = """
            SELECT
                LOWER(data_type) AS data_type,
                LOWER(is_nullable) AS is_nullable,
                LOWER(column_default) AS column_default
            FROM
                information_schema.columns
            WHERE
                table_catalog = %s
                AND table_name = %s
                AND column_name = %s
        """
        sql_params = [
            connection.settings_dict['NAME'],
            test_model_class._meta.db_table,
            test_model_class._meta.fields[1].get_attname_column()[1]
        ]

        with connection.cursor() as cursor:
            cursor.execute(sql_string, sql_params)
            record = cursor.fetchone()

        self.assertEqual(record[0], 'timestamp without time zone')
        self.assertEqual(record[1], 'no')
        self.assertEqual(record[2], 'current_timestamp')

    def test_table_structure_sqlite(self):
        """
        Test correct DB table structures with sqlite3 backend.

        Because all db_type method return values were tested in another test case, this method will
        only run a cursory set of checks on the actual database table structure. This module is
        supposed to test the custom field, not the underlying database.

        Apparently PRAGMA statements cannot be prepared and/or parameterized. A sqlite syntax
        exception is raised if one attempts to pass parameters to cursor.execute().

        The PRAGMA table_info() return columns:
        >>> [desc[0] for desc in cursor.description]
        >>> ['cid', 'name', 'type', 'notnull', 'dflt_value', 'pk']

        See:
            https://www.sqlite.org/pragma.html#pragma_table_info

        """
        test_model_class_name = test_utils.get_ts_model_class_name(
            **test_utils.TS_TEST_CONFIGS[2].kwargs_dict
        )
        test_model_class = getattr(test_models, test_model_class_name)
        connection = django.db.connections[test_utils.ALIAS_SQLITE]

        sql_string = 'PRAGMA table_info({!s})'.format(test_model_class._meta.db_table)

        with connection.cursor() as cursor:
            cursor.execute(sql_string)
            records = cursor.fetchall()
        ts_record = records[1]

        self.assertEqual(ts_record[2], 'DATETIME') # type
        self.assertEqual(ts_record[3], 1) # notnull
        self.assertEqual(ts_record[4], 'CURRENT_TIMESTAMP') # dflt_value

    def test_update(self):
        """
        Test that an UPDATE statement works correctly in specific cases.

        Test that the timestamp field value is unchanged when only auto_now_add is enabled and test
        that the timestamp field is automatically updated when only auto_now_update is enabled.

        Unfortunately, this test is impossible to isolate from any side effects of a broken INSERT
        operation in the timestamp field.

        """
        for alias in test_utils.get_db_aliases():
            engine = django.db.connections[alias].settings_dict['ENGINE']
            with self.subTest(backend=engine):
                self._test_update_no_auto(alias)
                self._test_update_auto(alias)
