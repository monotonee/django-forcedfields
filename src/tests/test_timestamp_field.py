"""
Tests of the timestamp field.

"""

import unittest.mock as mock

#import django.core.exceptions
import django.db
import django.test

from . import models as test_models
from . import utils as test_utils
import django_forcedfields


class TestTimestampField(django.test.TestCase):
    """
    Since django.test.TestCase automatically applies the INSTALLED_APPS models
    and migrations, any syntax violations in the SQL generated by the models or
    their fields will trigger database-level errors before the test suites are
    even run. Therefore, the test cases in this class are able to verify correct
    database field data type and parameters but cannot check for valid SQL
    beforehand.

    """

    multi_db = True

    @classmethod
    def setUpTestData(cls):
        """
        TODO: Get test DB entity names from Django's TestCase class directly?

        """
        cls._db_aliases = test_utils.get_db_aliases()
        #cls._test_table_name = test_models.FixedCharRecord._meta.db_table
        #cls._test_field_name = test_models.FixedCharRecord._meta.fields[1]\
            #.get_attname()
        #cls._test_field_max_length = test_models.FixedCharRecord._meta\
            #.fields[1].max_length
        # import pdb; pdb.set_trace()

    def _test_db_type_mysql(self):
        """
        Test output of the custom field db_type method with the MySQL backend.

        """
        kwarg_permutations = {
            'NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now': True},
            'NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now': True,
                'null': True},
            'NOT NULL DEFAULT CURRENT_TIMESTAMP': {
                'auto_now_add': True},
            'NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_add': True,
                'auto_now_update': True},
            'NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_add': True,
                'auto_now_update': True,
                'null': True},
            'NULL DEFAULT CURRENT_TIMESTAMP': {
                'auto_now_add': True,
                'null': True},
            'NOT NULL ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True},
            'NULL ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True,
                'null': True},
            'NOT NULL DEFAULT 0': {
                'default': 0},
            'NOT NULL DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True,
                'default': 0},
            'NULL DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True,
                'default': 0,
                'null': True},
            'NULL DEFAULT 0': {
                'default': 0,
                'null': True}}

        for expected_value, kwargs_dict in kwarg_permutations.items():
            expected_value = 'TIMESTAMP ' + expected_value
            current_options_string = ', '.join(kwargs_dict.keys())
            connection = django.db.connections[test_utils.ALIAS_MYSQL]

            with self.subTest(options=current_options_string):
                test_field = django_forcedfields.TimestampField(**kwargs_dict)
                self.assertEqual(test_field.db_type(connection), expected_value)

    def _test_db_type_postgresql(self):
        """
        Test output of custom field db_type method with the PostgreSQL backend.

        """
        raise NotImplementedError('Complete this test you lazy bastard.')

    def test_db_type(self):
        """
        Test simple output of the field's overridden "db_type" method.

        Only test thoroughly the overridden field behavior. Cursory checks will
        be performed to ensure fallback to Django default if necessary but
        those values will not be extensively checked.

        Valid permutations:
            auto_now
            auto_now + null
            auto_now_add
            auto_now_add + auto_now_update
            auto_now_add + auto_now_update + null
            auto_now_add + null
            auto_now_update
            auto_now_update + null
            default
            default + auto_now_update
            default + auto_now_update + null
            default + null

        """
        backend_subtests = {
            test_utils.ALIAS_MYSQL: self._test_db_type_mysql,
            test_utils.ALIAS_POSTGRESQL: self._test_db_type_postgresql
        }

        for alias, subtest_callable in backend_subtests.items():
            db_backend = django.db.connections[alias].settings_dict['ENGINE']
            with self.subTest(backend=db_backend):
                subtest_callable()

    def test_field_option_validation(self):
        """
        Ensure keyword option mutual exclusivity rules are enforced.

        'django.test.runner.DiscoverRunner'

        """
        raise NotImplementedError('Complete this test you lazy bastard.')

    def test_db_structure(self):
        """
        Test that the auto_now option creates correct DB data types.

        """
        #current_options_string = ', '.join(kwargs_dict.keys())
        #with self.subTest(options=current_options_string):
            #type_definition_dict = {
                #'ts_field_1': django_forcedfields.TimestampField(
                    #**kwargs_dict),
                #'__module__': __name__.split('.')[0] + '.models'}
            #TestModel = type(
                #'TestModel',
                #(django.db.models.Model,),
                #type_definition_dict)
        raise NotImplementedError('Complete this test you lazy bastard.')
