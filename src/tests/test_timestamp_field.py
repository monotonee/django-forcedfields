"""
Tests of the timestamp field.

"""

import unittest.mock as mock

import django.core.exceptions
import django.db
import django.test

from . import models as test_models
from . import utils as test_utils
import django_forcedfields


class TestTimestampField(django.test.TestCase):
    """
    Since django.test.TestCase automatically applies the INSTALLED_APPS models
    and migrations, any syntax violations in the SQL generated by the models or
    their fields will trigger database-level errors before the test suites are
    even run. Therefore, the test cases in this class are able to verify correct
    database field data type and parameters but cannot check for valid SQL
    beforehand.

    """

    multi_db = True

    @classmethod
    def setUpTestData(cls):
        """
        TODO: Get test DB entity names from Django's TestCase class directly?

        """
        cls._db_aliases = test_utils.get_db_aliases()
        #cls._test_table_name = test_models.FixedCharRecord._meta.db_table
        #cls._test_field_name = test_models.FixedCharRecord._meta.fields[1]\
            #.get_attname()
        #cls._test_field_max_length = test_models.FixedCharRecord._meta\
            #.fields[1].max_length
        # import pdb; pdb.set_trace()

    def _test_db_type_mysql(self):
        """
        Test output of the custom field db_type method with the MySQL backend.

        """
        kwarg_permutations = {
            'NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now': True},
            'NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now': True,
                'null': True},
            'NOT NULL DEFAULT CURRENT_TIMESTAMP': {
                'auto_now_add': True},
            'NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_add': True,
                'auto_now_update': True},
            'NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_add': True,
                'auto_now_update': True,
                'null': True},
            'NULL DEFAULT CURRENT_TIMESTAMP': {
                'auto_now_add': True,
                'null': True},
            'NOT NULL ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True},
            'NULL ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True,
                'null': True},
            'NOT NULL DEFAULT 0': {
                'default': 0},
            'NOT NULL DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True,
                'default': 0},
            'NULL DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True,
                'default': 0,
                'null': True},
            'NULL DEFAULT 0': {
                'default': 0,
                'null': True}}

        for expected_value, kwargs_dict in kwarg_permutations.items():
            expected_value = 'TIMESTAMP ' + expected_value
            current_options_string = ', '.join(kwargs_dict.keys())
            connection = django.db.connections[test_utils.ALIAS_MYSQL]

            with self.subTest(options=current_options_string):
                test_field = django_forcedfields.TimestampField(**kwargs_dict)
                self.assertEqual(test_field.db_type(connection), expected_value)

    def _test_db_type_postgresql(self):
        """
        Test output of custom field db_type method with the PostgreSQL backend.

        """
        raise NotImplementedError('Complete this test you lazy bastard.')

    def test_db_type(self):
        """
        Test simple output of the field's overridden "db_type" method.

        Only test thoroughly the overridden field behavior. Cursory checks will
        be performed to ensure fallback to Django default if necessary but
        those values will not be extensively checked.

        Valid permutations:
            auto_now
            auto_now + null
            auto_now_add
            auto_now_add + auto_now_update
            auto_now_add + auto_now_update + null
            auto_now_add + null
            auto_now_update
            auto_now_update + null
            default
            default + auto_now_update
            default + auto_now_update + null
            default + null

        """
        backend_subtests = {
            test_utils.ALIAS_MYSQL: self._test_db_type_mysql,
            test_utils.ALIAS_POSTGRESQL: self._test_db_type_postgresql}

        for alias, subtest_callable in backend_subtests.items():
            db_backend = django.db.connections[alias].settings_dict['ENGINE']
            with self.subTest(backend=db_backend):
                subtest_callable()

    def test_field_argument_check(self):
        """
        Ensure keyword argument rules are enforced.

        For some reason, model and field check() methods are not called during
        test database setup or when dynamically creating and migrating model
        classes. I don't know where and when the checks are run or when the
        checks framework raises the returned errors.

        I'm just going to test the check() method output here.

        Note:
            Validation covers actual model attribute values, not the field class
            instance arguments. Checks cover the field class arguments and
            configuration.

        See:
            https://docs.djangoproject.com/en/dev/topics/checks/

        """
        check_tests = {
            'fields.E160' : {
                'auto_now': True,
                'auto_now_add': True},
            'django_forcedfields.E160' : {
                'auto_now': True,
                'auto_now_update': True}}

        for check_error_id, kwargs in check_tests.items():
            test_model_members = {
                'ts_field_1': django_forcedfields.TimestampField(**kwargs),
                '__module__':  __name__}
            TestModel = type(
                'TestModel',
                (django.db.models.Model,),
                test_model_members)
            model_instance = TestModel(ts_field_1='1991-01-01 00:00:01')
            check_results = model_instance.check()

            with self.subTest(field_args=', '.join(kwargs.keys())):
                self.assertEqual(len(check_results), 1)
                self.assertEqual(check_results[0].id, check_error_id)

    def test_mysql_table_structure(self):
        """
        Test correct DB table structures with MySQL backend.

        Because all tb_type method return values were tested in another test
        case, this method will only run a cursory set of checks on the actual
        database table structure. This module is supposed to test the custom
        field, not the underlying database.

        """
        sql_string = """
            SELECT
                `DATA_TYPE`,
                `IS_NULLABLE`,
                `COLUMN_DEFAULT`,
                `EXTRA`
            FROM
                `information_schema`.`COLUMNS`
            WHERE
                `TABLE_SCHEMA` = %s
                AND `TABLE_NAME` = %s
                AND `COLUMN_NAME` = %s
        """
        #sql_params = [
            #django.db.connections[test_utils.ALIAS_MYSQL].settings_dict['NAME'],
            #self._test_table_name,
            #self._test_field_name]

        #cursor = django.db.connections[test_utils.ALIAS_MYSQL].cursor()
        #cursor.execute(sql_string, sql_params)
        #record = cursor.fetchone()

        #self.assertEqual(record[0], 'char')
        #self.assertEqual(record[1], self._test_field_max_length)

        raise NotImplementedError('Complete this test you lazy bastard.')

    def test_field_values(self):
        """
        Test that the values are saved correctly.

        For MySQL, this should bypass most of the django.db.DateTimeField value
        overrides.

        """
        raise NotImplementedError('Complete this test you lazy bastard.')
