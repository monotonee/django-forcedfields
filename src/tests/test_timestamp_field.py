"""
Tests of the timestamp field.

"""

import unittest.mock as mock

import django.core.exceptions
import django.core.management
import django.db
import django.test

from . import models as test_models
from . import utils as test_utils
import django_forcedfields


class TestTimestampField(django.test.TestCase):
    """
    Since django.test.TestCase automatically applies the INSTALLED_APPS models
    and migrations, any syntax violations in the SQL generated by the models or
    their fields will trigger database-level errors before the test suites are
    even run. Therefore, the test cases in this class are able to verify correct
    database field data type and parameters but cannot check for valid SQL
    beforehand.

    """

    multi_db = True

    @classmethod
    def setUpTestData(cls):
        """
        TODO: Get test DB entity names from Django's TestCase class directly?

        """
        cls._db_aliases = test_utils.get_db_aliases()

    def test_db_type(self):
        """
        Test simple output of the field's overridden "db_type" method.

        Only test thoroughly the overridden field behavior. Cursory checks will
        be performed to ensure fallback to Django default if necessary but
        those values will not be extensively checked.

        """
        backend_subtests = {
            test_utils.ALIAS_MYSQL: self._test_db_type_mysql,
            test_utils.ALIAS_POSTGRESQL: self._test_db_type_postgresql}

        for alias, subtest_callable in backend_subtests.items():
            db_backend = django.db.connections[alias].settings_dict['ENGINE']
            with self.subTest(backend=db_backend):
                subtest_callable()

    def _test_db_type_mysql(self):
        """
        Test output of the custom field db_type method with the MySQL backend.

        I don't like having "all permutations" defined in more than one place.
        Valid kwargs are also defined in tests.utils.

        TODO:
            Devise way to centralize a valid kwarg permutation definition.

        """
        kwarg_permutations = {
            'NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now': True},
            'NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now': True,
                'null': True},
            'NOT NULL DEFAULT CURRENT_TIMESTAMP': {
                'auto_now_add': True},
            'NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_add': True,
                'auto_now_update': True},
            'NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_add': True,
                'auto_now_update': True,
                'null': True},
            'NULL DEFAULT CURRENT_TIMESTAMP': {
                'auto_now_add': True,
                'null': True},
            'NOT NULL ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True},
            'NULL ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True,
                'null': True},
            'NOT NULL DEFAULT 0': {
                'default': 0},
            'NOT NULL DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True,
                'default': 0},
            'NULL DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP': {
                'auto_now_update': True,
                'default': 0,
                'null': True},
            'NULL DEFAULT 0': {
                'default': 0,
                'null': True}}

        for expected_value, kwargs_dict in kwarg_permutations.items():
            expected_value = 'TIMESTAMP ' + expected_value
            current_options_string = ', '.join(kwargs_dict.keys())
            connection = django.db.connections[test_utils.ALIAS_MYSQL]

            with self.subTest(options=current_options_string):
                test_field = django_forcedfields.TimestampField(**kwargs_dict)
                self.assertEqual(test_field.db_type(connection), expected_value)

    def _test_db_type_postgresql(self):
        """
        Test output of custom field db_type method with the PostgreSQL backend.

        """
        raise NotImplementedError('Complete this test you lazy bastard.')

    def test_field_argument_check(self):
        """
        Ensure keyword argument rules are enforced.

        For some reason, model and field check() methods are not called during
        test database setup or when dynamically creating and migrating model
        classes. I don't know where and when the checks are run or when the
        checks framework raises the returned errors.

        I'm just going to test the check() method output here.

        Note:
            Validation covers actual model attribute values, not the field class
            instance arguments. Checks cover the field class arguments and
            configuration.

        See:
            https://docs.djangoproject.com/en/dev/topics/checks/

        """
        check_tests = {
            'fields.E160' : {
                'auto_now': True,
                'auto_now_add': True},
            'django_forcedfields.E160' : {
                'auto_now': True,
                'auto_now_update': True}}

        for check_error_id, kwargs in check_tests.items():
            test_model_members = {
                'ts_field_1': django_forcedfields.TimestampField(**kwargs),
                '__module__':  __name__}
            TestModel = type(
                'TestModel',
                (django.db.models.Model,),
                test_model_members)
            model_instance = TestModel(ts_field_1='1991-01-01 00:00:01')
            check_results = model_instance.check()

            with self.subTest(field_args=', '.join(kwargs.keys())):
                self.assertEqual(len(check_results), 1)
                self.assertEqual(check_results[0].id, check_error_id)

    def test_mysql_table_structure(self):
        """
        Test correct DB table structures with MySQL backend.

        Because all db_type method return values were tested in another test
        case, this method will only run a cursory set of checks on the actual
        database table structure. This module is supposed to test the custom
        field, not the underlying database.

        information_schema.COLUMNS.COLUMN_DEFAULT is a longtext field.

        See:
            https://mariadb.com/kb/en/mariadb/create-table/
            https://mariadb.com/kb/en/mariadb/sql-statements-that-cause-an-implicit-commit/

        """
        test_model_class_name = test_utils.get_ts_field_test_model_class_name(
            **test_utils.TS_FIELD_TEST_KWARG_PERMUTATIONS[0])
        test_model = getattr(test_models, test_model_class_name)
        connection = django.db.connections[test_utils.ALIAS_MYSQL]

        sql_string = """
            SELECT
                LOWER(`DATA_TYPE`) AS `DATA_TYPE`,
                LOWER(`IS_NULLABLE`) AS `IS_NULLABLE`,
                LOWER(CAST(`COLUMN_DEFAULT` AS CHAR(32))) AS `COLUMN_DEFAULT`,
                LOWER(`EXTRA`) AS `EXTRA`
            FROM
                `information_schema`.`COLUMNS`
            WHERE
                `TABLE_SCHEMA` = %s
                AND `TABLE_NAME` = %s
                AND `COLUMN_NAME` = %s
        """
        sql_params = [
            connection.settings_dict['NAME'],
            test_model._meta.db_table,
            test_model._meta.fields[1].get_attname_column()[1]]

        with connection.cursor() as cursor:
            cursor.execute(sql_string, sql_params)
            record = cursor.fetchone()

        self.assertEqual(record[0], 'timestamp')
        self.assertEqual(record[1], 'no')
        self.assertEqual(record[2], 'current_timestamp')
        self.assertEqual(record[3], 'on update current_timestamp')

    def test_postgresql_table_structure(self):
        raise NotImplementedError('Complete this test you lazy bastard.')

    def test_field_values(self):
        """
        Test that the values are saved correctly.

        For MySQL, this should bypass most of the django.db.DateTimeField value
        overrides.

        """
        raise NotImplementedError('Complete this test you lazy bastard.')

